[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 ggtranscript authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"/articles/ggtranscript.html","id":"example-data","dir":"Articles","previous_headings":"Input data","what":"Example data","title":"Getting started","text":"order showcase package’s functionality, ggtranscript includes example transcript annotation genes SOD1 PKNOX1, well set unannotated junctions associated SOD1. specific genes unimportant, chosen arbitrarily illustration. However, worth noting input data ggtranscript, ggplot2 extension, required data.frame tibble.","code":"sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  pknox1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type       gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>      <chr>     <chr>           #> 1 21       42974510 43033931 +      gene       PKNOX1    NA              #> 2 21       42974510 43033931 +      transcript PKNOX1    PKNOX1-203      #> 3 21       42974510 42974664 +      exon       PKNOX1    PKNOX1-203      #> 4 21       43004326 43004432 +      exon       PKNOX1    PKNOX1-203      #> 5 21       43007491 43007618 +      exon       PKNOX1    PKNOX1-203      #> 6 21       43013068 43013238 +      exon       PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  sod1_junctions #> # A tibble: 5 × 5 #>   seqnames    start      end strand mean_count #>   <fct>       <int>    <int> <fct>       <dbl> #> 1 chr21    31659787 31666448 +           0.463 #> 2 chr21    31659842 31660554 +           0.831 #> 3 chr21    31659842 31663794 +           0.316 #> 4 chr21    31659842 31667257 +           4.35  #> 5 chr21    31660351 31663789 +           0.324"},{"path":"/articles/ggtranscript.html","id":"importing-data-from-a-gtf","dir":"Articles","previous_headings":"Input data","what":"Importing data from a gtf","title":"Getting started","text":"may asking, gtf file GRanges object? demonstrates wrangle gtf required format ggtranscript extract relevant annotation particular gene interest. purposes vignette, download gtf (Ensembl version 105), load gtf R using rtracklayer::import(). note, loaded gtf GRanges class object. input data ggtranscript, ggplot2 extension, required data.frame tibble. can convert GRanges data.frame using .data.frame tibble via dplyr::as_tibble(). Either fine respect ggtranscript, however prefer tibbles data.frames several reasons. Now gtf tibble (data.frame object), can dplyr::filter() rows dplyr::select() columns keep annotation columns required specific gene interest. , illustrate obtain annotation gene SOD1, ready plotting ggtranscript.","code":"# download ens 105 gtf into a temporary directory gtf_path <- file.path(tempdir(), \"Homo_sapiens.GRCh38.105.chr.gtf.gz\")  download.file(     paste0(         \"http://ftp.ensembl.org/pub/release-105/gtf/homo_sapiens/\",         \"Homo_sapiens.GRCh38.105.chr.gtf.gz\"     ),     destfile = gtf_path )  gtf <- rtracklayer::import(gtf_path)  class(gtf) #> [1] \"GRanges\" #> attr(,\"package\") #> [1] \"GenomicRanges\" gtf <- gtf %>% dplyr::as_tibble()  class(gtf) #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\" # filter your gtf for the gene of interest, here \"SOD1\" gene_of_interest <- \"SOD1\"  sod1_annotation_from_gtf <- gtf %>%    dplyr::filter(     !is.na(gene_name),      gene_name == gene_of_interest   )   # extract the required annotation columns sod1_annotation_from_gtf <- sod1_annotation_from_gtf %>%    dplyr::select(     seqnames,     start,     end,     strand,     type,     gene_name,     transcript_name,     transcript_biotype   )  sod1_annotation_from_gtf %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>"},{"path":"/articles/ggtranscript.html","id":"importing-data-from-a-bed-file","dir":"Articles","previous_headings":"Input data","what":"Importing data from a bed file","title":"Getting started","text":"users like plot ranges bed file using ggtranscript, can first import bed file R using rtracklayer::import.bed(). method create UCSCData object. UCSCData object can coerced tibble, data structure can plotted using ggplot2/ggtranscript, using dplyr::as_tibble().","code":"# for the example, we'll use the test bed file provided by rtracklayer  test_bed <- system.file(\"tests/test.bed\", package = \"rtracklayer\")  bed <- rtracklayer::import.bed(test_bed)  class(bed) #> [1] \"UCSCData\" #> attr(,\"package\") #> [1] \"rtracklayer\" bed <- bed %>% dplyr::as_tibble()  class(bed) #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"  bed %>% head() #> # A tibble: 5 × 12 #>   seqnames   start    end width strand name  score itemRgb thick.start thick.end #>   <fct>      <int>  <int> <int> <fct>  <chr> <dbl> <chr>         <int>     <int> #> 1 chr7      1.27e8 1.27e8  1167 +      Pos1      0 #FF0000   127471197 127472363 #> 2 chr7      1.27e8 1.27e8  1167 +      Pos2      2 #FF0000   127472364 127473530 #> 3 chr7      1.27e8 1.27e8  1167 -      Neg1      0 #FF0000   127473531 127474697 #> 4 chr9      1.27e8 1.27e8  1167 +      Pos3      5 #FF0000   127474698 127475864 #> 5 chr9      1.27e8 1.27e8  1167 -      Neg2      5 #0000FF   127475865 127477031 #> # ℹ 2 more variables: thick.width <int>, blocks <list>"},{"path":[]},{"path":"/articles/ggtranscript.html","id":"required-aesthetics","dir":"Articles","previous_headings":"Basic usage","what":"Required aesthetics","title":"Getting started","text":"ggtranscript introduces 5 new geoms designed simplify visualization transcript structure annotation; geom_range(), geom_half_range(), geom_intron(), geom_junction() geom_junction_label_repel(). required aesthetics (aes()) geoms designed match data formats widely used genetic transcriptomic analyses:","code":""},{"path":"/articles/ggtranscript.html","id":"plotting_exons_and_introns","dir":"Articles","previous_headings":"Basic usage","what":"Plotting exons and introns","title":"Getting started","text":"simplest case, core components transcript structure exons introns, can plotted using geom_range() geom_intron(). order facilitate , ggtranscript also provides to_intron(), converts exon co-ordinates introns. Therefore, can plot transcript structures exons input just lines code. 📌: ggtranscript geoms share required aesthetics, recommended set via ggplot(), rather individual geom_*() calls avoid code duplication.","code":"# to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(type == \"exon\")  sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(         aes(fill = transcript_biotype)     ) +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\"),         aes(strand = strand)     )"},{"path":"/articles/ggtranscript.html","id":"differentiating-utrs-from-the-coding-sequence","dir":"Articles","previous_headings":"Basic usage","what":"Differentiating UTRs from the coding sequence","title":"Getting started","text":"suggested ’s name, geom_range() designed visualize range-based transcript annotation. includes limited exons. instance, protein coding transcripts can useful visually distinguish coding sequence (CDS) transcript ’s UTRs. can achieved adjusting height fill geom_range() overlaying CDS top exons (including UTRs).","code":"# filter for only exons from protein coding transcripts sod1_exons_prot_cod <- sod1_exons %>%     dplyr::filter(transcript_biotype == \"protein_coding\")  # obtain cds sod1_cds <- sod1_annotation %>% dplyr::filter(type == \"CDS\")  sod1_exons_prot_cod %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(         fill = \"white\",         height = 0.25     ) +     geom_range(         data = sod1_cds     ) +     geom_intron(         data = to_intron(sod1_exons_prot_cod, \"transcript_name\"),         aes(strand = strand),         arrow.min.intron.length = 500,     )"},{"path":"/articles/ggtranscript.html","id":"plotting-junctions","dir":"Articles","previous_headings":"Basic usage","what":"Plotting junctions","title":"Getting started","text":"geom_junction() plots curved lines intended represent junction reads. Junctions reads obtained RNA-sequencing (RNA-seq) data map gapped alignment genome. Often, gap indicative splicing event, can also originate genomic events indels. can useful visually overlay junctions top existing transcript structure. example, can help understand existing transcripts expressed RNA-seq sample inform location interpretation novel splice sites. geom_junction_label_repel() adds labels junction curves. can useful labeling junctions measure expression support read counts percent-spliced-. Alternatively, may choose visually map measure thickness junction curves adjusting size aes(). , shown , options can combined.","code":"# extract exons and cds for the MANE-select transcript sod1_201_exons <- sod1_exons %>% dplyr::filter(transcript_name == \"SOD1-201\") sod1_201_cds <- sod1_cds %>% dplyr::filter(transcript_name == \"SOD1-201\")  # add transcript name column to junctions for plotting sod1_junctions <- sod1_junctions %>% dplyr::mutate(transcript_name = \"SOD1-201\")  sod1_201_exons %>%   ggplot(aes(     xstart = start,     xend = end,     y = transcript_name   )) +   geom_range(     fill = \"white\",      height = 0.25   ) +   geom_range(     data = sod1_201_cds   ) +    geom_intron(     data = to_intron(sod1_201_exons, \"transcript_name\")   ) +    geom_junction(     data = sod1_junctions,     aes(size = mean_count),     junction.y.max = 0.5   ) +   geom_junction_label_repel(     data = sod1_junctions,     aes(label = round(mean_count, 2)),     junction.y.max = 0.5   ) +    scale_size_continuous(range = c(0.1, 1)) #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated."},{"path":[]},{"path":"/articles/ggtranscript.html","id":"context","dir":"Articles","previous_headings":"Visualizing transcript structure differences","what":"Context","title":"Getting started","text":"One primary reasons visualizing transcript structures better observe differences . Often can achieved simply plotting exons introns shown basic usage. However, longer, complex transcripts may straight forward. example, transcripts PKNOX1 relatively long introns, makes comparison transcript structures (especially small differences exons) difficult. 📌: relatively short introns, strand arrows may overlap exons. cases, arrow.min.intron.length parameter geom_intron() can used set minimum intron length strand arrow plotted.","code":"# extract exons pknox1_exons <- pknox1_annotation %>% dplyr::filter(type == \"exon\")  pknox1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(         aes(fill = transcript_biotype)     ) +     geom_intron(         data = to_intron(pknox1_exons, \"transcript_name\"),         aes(strand = strand),          arrow.min.intron.length = 3500     )"},{"path":"/articles/ggtranscript.html","id":"improving-transcript-structure-visualisation-using-shorten_gaps","dir":"Articles","previous_headings":"Visualizing transcript structure differences","what":"Improving transcript structure visualisation using shorten_gaps()","title":"Getting started","text":"ggtranscript provides helper function shorten_gaps(), reduces size gaps (regions overlap exon). shorten_gaps() rescales exon intron co-ordinates, preserving original exon alignment. allows hone differences interest, exonic structure. 📌: rescaled co-ordinates returned shorten_gaps() match original genomic positions. Therefore, recommended shorten_gaps() used visualizations purposes .","code":"# extract exons pknox1_exons <- pknox1_annotation %>% dplyr::filter(type == \"exon\")  pknox1_rescaled <- shorten_gaps(   exons = pknox1_exons,    introns = to_intron(pknox1_exons, \"transcript_name\"),    group_var = \"transcript_name\" )  # shorten_gaps() returns exons and introns all in one data.frame() # let's split these for plotting  pknox1_rescaled_exons <- pknox1_rescaled %>% dplyr::filter(type == \"exon\")  pknox1_rescaled_introns <- pknox1_rescaled %>% dplyr::filter(type == \"intron\")   pknox1_rescaled_exons %>%      ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(         aes(fill = transcript_biotype)     ) +     geom_intron(         data = pknox1_rescaled_introns,         aes(strand = strand),          arrow.min.intron.length = 300     )"},{"path":"/articles/ggtranscript.html","id":"comparing-between-two-transcripts-using-geom_half_range","dir":"Articles","previous_headings":"Visualizing transcript structure differences","what":"Comparing between two transcripts using geom_half_range()","title":"Getting started","text":"interested differences two transcripts, can use geom_half_range() whilst adjusting range.orientation plot exons opposite sides transcript structure. can reveal small differences exon structure, observed 5’ ends PKNOX1-201 PKNOX1-203.","code":"# extract the two transcripts to be compared pknox1_rescaled_201_exons <- pknox1_rescaled_exons %>%    dplyr::filter(transcript_name == \"PKNOX1-201\") pknox1_rescaled_203_exons <- pknox1_rescaled_exons %>%    dplyr::filter(transcript_name == \"PKNOX1-203\")  pknox1_rescaled_201_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = \"PKNOX1-201/203\"     )) +     geom_half_range() +     geom_intron(         data = to_intron(pknox1_rescaled_201_exons, \"transcript_name\"),          arrow.min.intron.length = 300     ) +     geom_half_range(         data = pknox1_rescaled_203_exons,         range.orientation = \"top\",          fill = \"purple\"     ) +     geom_intron(         data = to_intron(pknox1_rescaled_203_exons, \"transcript_name\"),          arrow.min.intron.length = 300     )"},{"path":"/articles/ggtranscript.html","id":"comparing-many-transcripts-to-a-single-reference-transcript-using-to_diff","dir":"Articles","previous_headings":"Visualizing transcript structure differences","what":"Comparing many transcripts to a single reference transcript using to_diff()","title":"Getting started","text":"Sometimes, can useful visualize differences several transcripts respect one transcript. example, may interested transcripts differ structure MANE-select transcript. exploration can reveal whether certain important regions missing novel regions added, hinting differences transcript function. to_diff() helper function designed situation. , apply PKNOX1, finding differences transcripts MANE-select transcript (PKNOX1-201). 📌: Although , apply to_diff() rescaled exons intron (outputted shorten_gaps()), to_diff() can also applied original, unscaled transcripts effect.","code":"mane <- pknox1_rescaled_201_exons  not_mane <- pknox1_rescaled_exons %>%    dplyr::filter(transcript_name != \"PKNOX1-201\")  pknox1_rescaled_diffs <- to_diff(     exons = not_mane,     ref_exons = mane,     group_var = \"transcript_name\" )  pknox1_rescaled_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = pknox1_rescaled_introns,         arrow.min.intron.length = 300     ) +     geom_range(         data = pknox1_rescaled_diffs,         aes(fill = diff_type),         alpha = 0.2     )"},{"path":"/articles/ggtranscript.html","id":"integrating-existing-ggplot2-functionality","dir":"Articles","previous_headings":"","what":"Integrating existing ggplot2 functionality","title":"Getting started","text":"ggplot2 extension, ggtranscript inherits ggplot2’s familiarity flexibility, enabling users intuitively adjust aesthetics, parameters, scales etc well complement ggtranscript geoms existing ggplot2 geoms create informative, publication-ready plots. list outlining examples complementing ggtranscript existing ggplot2 functionality found useful: Adding exon annotation exon number/order using add_exon_number() geom_text()  Zooming areas interest using coord_cartesian() ggforce::facet_zoom()  Plotting mutations using geom_vline()  Beautifying plots using themes scales","code":"base_sod1_plot <- sod1_exons %>%    ggplot(aes(     xstart = start,     xend = end,     y = transcript_name   )) +   geom_range(     aes(fill = transcript_biotype)   ) +   geom_intron(     data = to_intron(sod1_exons, \"transcript_name\"),     aes(strand = strand)   )   base_sod1_plot +    geom_text(     data = add_exon_number(sod1_exons, \"transcript_name\"),     aes(       x = (start + end) / 2, # plot label at midpoint of exon       label = exon_number     ),     size = 3.5,     nudge_y = 0.4   ) base_sod1_plot +    coord_cartesian(xlim = c(31665500, 31669000)) example_mutation <- dplyr::tibble(   transcript_name = \"SOD1-204\",    position = 31661600 )  # xstart and xend are set here to override the default aes() base_sod1_plot +    geom_vline(     data = example_mutation,      aes(       xintercept = position,        xstart = NULL,       xend = NULL       ),      linetype = 2,     colour = \"red\"   ) base_sod1_plot +    theme_bw() +    scale_x_continuous(name = \"Position\") +    scale_y_discrete(name = \"Transcript name\") +    scale_fill_discrete(     name = \"Transcript biotype\",     labels = c(\"Processed transcript\", \"Protein-coding\")     )"},{"path":"/articles/ggtranscript.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Getting started","text":"","code":"#> ─ Session info ─────────────────────────────────────────────────────────────────────────────────────────────────────── #>  setting  value #>  version  R version 4.4.1 (2024-06-14) #>  os       Ubuntu 22.04.4 LTS #>  system   x86_64, linux-gnu #>  ui       X11 #>  language en #>  collate  en_US.UTF-8 #>  ctype    en_US.UTF-8 #>  tz       UTC #>  date     2024-08-24 #>  pandoc   3.2 @ /usr/bin/ (via rmarkdown) #>  #> ─ Packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────── #>  package              * version   date (UTC) lib source #>  abind                  1.4-5     2016-07-21 [1] RSPM (R 4.4.0) #>  Biobase                2.64.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  BiocGenerics         * 0.50.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  BiocIO                 1.14.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  BiocManager            1.30.24   2024-08-20 [1] RSPM (R 4.4.0) #>  BiocParallel           1.38.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  BiocStyle            * 2.32.1    2024-06-16 [1] Bioconductor 3.19 (R 4.4.1) #>  Biostrings             2.72.1    2024-06-02 [1] Bioconductor 3.19 (R 4.4.1) #>  bitops                 1.0-8     2024-07-29 [1] RSPM (R 4.4.0) #>  bookdown               0.40      2024-07-02 [1] RSPM (R 4.4.0) #>  bslib                  0.8.0     2024-07-29 [2] RSPM (R 4.4.0) #>  cachem                 1.1.0     2024-05-16 [2] RSPM (R 4.4.0) #>  cli                    3.6.3     2024-06-21 [2] RSPM (R 4.4.0) #>  codetools              0.2-20    2024-03-31 [3] CRAN (R 4.4.1) #>  colorspace             2.1-1     2024-07-26 [1] RSPM (R 4.4.0) #>  crayon                 1.5.3     2024-06-20 [2] RSPM (R 4.4.0) #>  curl                   5.2.1     2024-03-01 [2] RSPM (R 4.4.0) #>  DelayedArray           0.30.1    2024-05-07 [1] Bioconductor 3.19 (R 4.4.1) #>  desc                   1.4.3     2023-12-10 [2] RSPM (R 4.4.0) #>  digest                 0.6.37    2024-08-19 [2] RSPM (R 4.4.0) #>  dplyr                * 1.1.4     2023-11-17 [1] RSPM (R 4.4.0) #>  evaluate               0.24.0    2024-06-10 [2] RSPM (R 4.4.0) #>  fansi                  1.0.6     2023-12-08 [2] RSPM (R 4.4.0) #>  farver                 2.1.2     2024-05-13 [1] RSPM (R 4.4.0) #>  fastmap                1.2.0     2024-05-15 [2] RSPM (R 4.4.0) #>  fs                     1.6.4     2024-04-25 [2] RSPM (R 4.4.0) #>  generics               0.1.3     2022-07-05 [1] RSPM (R 4.4.0) #>  GenomeInfoDb         * 1.40.1    2024-05-24 [1] Bioconductor 3.19 (R 4.4.1) #>  GenomeInfoDbData       1.2.12    2024-06-25 [1] Bioconductor #>  GenomicAlignments      1.40.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  GenomicRanges        * 1.56.1    2024-06-12 [1] Bioconductor 3.19 (R 4.4.1) #>  ggplot2              * 3.5.1     2024-04-23 [1] RSPM (R 4.4.0) #>  ggrepel                0.9.5     2024-01-10 [1] RSPM (R 4.4.0) #>  ggtranscript         * 1.0.0     2024-08-24 [1] local #>  glue                   1.7.0     2024-01-09 [2] RSPM (R 4.4.0) #>  gtable                 0.3.5     2024-04-22 [1] RSPM (R 4.4.0) #>  highr                  0.11      2024-05-26 [2] RSPM (R 4.4.0) #>  htmltools              0.5.8.1   2024-04-04 [2] RSPM (R 4.4.0) #>  htmlwidgets            1.6.4     2023-12-06 [2] RSPM (R 4.4.0) #>  httr                   1.4.7     2023-08-15 [2] RSPM (R 4.4.0) #>  IRanges              * 2.38.1    2024-07-03 [1] Bioconductor 3.19 (R 4.4.1) #>  jquerylib              0.1.4     2021-04-26 [2] RSPM (R 4.4.0) #>  jsonlite               1.8.8     2023-12-04 [2] RSPM (R 4.4.0) #>  knitr                  1.48      2024-07-07 [2] RSPM (R 4.4.0) #>  labeling               0.4.3     2023-08-29 [1] RSPM (R 4.4.0) #>  lattice                0.22-6    2024-03-20 [3] CRAN (R 4.4.1) #>  lifecycle              1.0.4     2023-11-07 [2] RSPM (R 4.4.0) #>  magrittr             * 2.0.3     2022-03-30 [2] RSPM (R 4.4.0) #>  Matrix                 1.7-0     2024-04-26 [3] CRAN (R 4.4.1) #>  MatrixGenerics         1.16.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  matrixStats            1.3.0     2024-04-11 [1] RSPM (R 4.4.0) #>  munsell                0.5.1     2024-04-01 [1] RSPM (R 4.4.0) #>  pillar                 1.9.0     2023-03-22 [2] RSPM (R 4.4.0) #>  pkgconfig              2.0.3     2019-09-22 [2] RSPM (R 4.4.0) #>  pkgdown                2.1.0     2024-07-06 [2] RSPM (R 4.4.0) #>  R6                     2.5.1     2021-08-19 [2] RSPM (R 4.4.0) #>  ragg                   1.3.2     2024-05-15 [2] RSPM (R 4.4.0) #>  Rcpp                   1.0.13    2024-07-17 [2] RSPM (R 4.4.0) #>  RCurl                  1.98-1.16 2024-07-11 [1] RSPM (R 4.4.0) #>  restfulr               0.0.15    2022-06-16 [1] RSPM (R 4.4.1) #>  rjson                  0.2.22    2024-08-20 [1] RSPM (R 4.4.0) #>  rlang                  1.1.4     2024-06-04 [2] RSPM (R 4.4.0) #>  rmarkdown              2.28      2024-08-17 [2] RSPM (R 4.4.0) #>  Rsamtools              2.20.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  rtracklayer          * 1.64.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  S4Arrays               1.4.1     2024-05-20 [1] Bioconductor 3.19 (R 4.4.1) #>  S4Vectors            * 0.42.1    2024-07-03 [1] Bioconductor 3.19 (R 4.4.1) #>  sass                   0.4.9     2024-03-15 [2] RSPM (R 4.4.0) #>  scales                 1.3.0     2023-11-28 [1] RSPM (R 4.4.0) #>  sessioninfo          * 1.2.2     2021-12-06 [2] RSPM (R 4.4.0) #>  SparseArray            1.4.8     2024-05-24 [1] Bioconductor 3.19 (R 4.4.1) #>  SummarizedExperiment   1.34.0    2024-05-01 [1] Bioconductor 3.19 (R 4.4.1) #>  systemfonts            1.1.0     2024-05-15 [2] RSPM (R 4.4.0) #>  textshaping            0.4.0     2024-05-24 [2] RSPM (R 4.4.0) #>  tibble                 3.2.1     2023-03-20 [2] RSPM (R 4.4.0) #>  tidyselect             1.2.1     2024-03-11 [1] RSPM (R 4.4.0) #>  UCSC.utils             1.0.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  utf8                   1.2.4     2023-10-22 [2] RSPM (R 4.4.0) #>  vctrs                  0.6.5     2023-12-01 [2] RSPM (R 4.4.0) #>  withr                  3.0.1     2024-07-31 [2] RSPM (R 4.4.0) #>  xfun                   0.47      2024-08-17 [2] RSPM (R 4.4.0) #>  XML                    3.99-0.17 2024-06-25 [1] RSPM (R 4.4.0) #>  XVector                0.44.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  yaml                   2.3.10    2024-07-26 [2] RSPM (R 4.4.0) #>  zlibbioc               1.50.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1) #>  #>  [1] /__w/_temp/Library #>  [2] /usr/local/lib/R/site-library #>  [3] /usr/local/lib/R/library #>  #> ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Zhang. Author, maintainer. Emil Gustavsson. Author. Regina Reynolds. Contributor. Sonia Ruiz. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gustavsson EK, Zhang D, Reynolds RH, Garcia-Ruiz S, Ryten M (2022). “ggtranscript: R package visualization interpretation transcript isoforms using ggplot2.” Bioinformatics. doi:10.1093/bioinformatics/btac409, https://academic.oup.com/bioinformatics/article/38/15/3844/6617821.","code":"@Article{,   title = {ggtranscript: an R package for the visualization and interpretation of transcript isoforms using ggplot2},   author = {Emil K Gustavsson and David Zhang and Regina H Reynolds and Sonia Garcia-Ruiz and Mina Ryten},   year = {2022},   journal = {Bioinformatics},   doi = {https://doi.org/10.1093/bioinformatics/btac409},   url = {https://academic.oup.com/bioinformatics/article/38/15/3844/6617821}, }"},{"path":"/index.html","id":"ggtranscript-","dir":"","previous_headings":"","what":"Visualizing Transcript Structure and Annotation using ggplot2","title":"Visualizing Transcript Structure and Annotation using ggplot2","text":"ggtranscript ggplot2 extension makes easy visualize transcript structure annotation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Visualizing Transcript Structure and Annotation using ggplot2","text":"","code":"# you can install the development version of ggtranscript from GitHub: # install.packages(\"devtools\") devtools::install_github(\"dzhang32/ggtranscript\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Visualizing Transcript Structure and Annotation using ggplot2","text":"ggtranscript introduces 5 new geoms (geom_range(), geom_half_range(), geom_intron(), geom_junction() geom_junction_label_repel()) several helper functions designed facilitate visualization transcript structure annotation. following guide takes quick tour using geoms, detailed overview see Getting Started tutorial. geom_range() geom_intron() enable plotting exons introns, core components transcript annotation. ggtranscript also provides to_intron(), converts exon co-ordinates corresponding introns. Together, ggtranscript enables users plot transcript structures exons required input just lines code.  ggtranscript provides helper function shorten_gaps(), reduces size gaps. shorten_gaps() rescales exon intron co-ordinates preserve original exon alignment. allows hone differences exonic structure, can particularly useful transcript relatively long introns.  geom_range() can used range-based genomic annotation. example, plotting protein-coding transcripts, users may find helpful visually distinguish coding segments UTRs.  geom_half_range() takes advantage vertical symmetry transcript annotation plotting half range top bottom transcript structure. One use case geom_half_range() visualize differences transcript structure clearly.  ggplot2 extension, ggtranscript inherits familiarity functionality ggplot2. instance, leveraging coord_cartesian() users can zoom regions interest.  geom_junction() enables plotting junction curves, can overlaid across transcript structures. geom_junction_label_repel() adds label junction curves, can often useful mark junctions metric usage read counts.  Alternatively, users may prefer map junction read counts thickness junction curves. ggplot2 extension, can done intuitively modifying size aes() geom_junction(). addition, modifying ggplot2 scales themes, users can easily create informative, publication-ready plots.","code":"library(magrittr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) library(ggtranscript)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      <NA>            #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(type == \"exon\")  sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(         aes(fill = transcript_biotype)     ) +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\"),         aes(strand = strand)     ) sod1_rescaled <- shorten_gaps(   sod1_exons,    to_intron(sod1_exons, \"transcript_name\"),    group_var = \"transcript_name\"   )  sod1_rescaled %>%     dplyr::filter(type == \"exon\") %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(       aes(fill = transcript_biotype)     ) +     geom_intron(         data = sod1_rescaled %>% dplyr::filter(type == \"intron\"),          arrow.min.intron.length = 200     ) # filter for only exons from protein coding transcripts sod1_exons_prot_cod <- sod1_exons %>%     dplyr::filter(transcript_biotype == \"protein_coding\")  # obtain cds sod1_cds <- sod1_annotation %>% dplyr::filter(type == \"CDS\")  sod1_exons_prot_cod %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(         fill = \"white\",         height = 0.25     ) +     geom_range(         data = sod1_cds     ) +     geom_intron(         data = to_intron(sod1_exons_prot_cod, \"transcript_name\"),         aes(strand = strand),         arrow.min.intron.length = 500,     ) # extract exons and cds for the two transcripts to be compared sod1_201_exons <- sod1_exons %>% dplyr::filter(transcript_name == \"SOD1-201\") sod1_201_cds <- sod1_cds %>% dplyr::filter(transcript_name == \"SOD1-201\") sod1_202_exons <- sod1_exons %>% dplyr::filter(transcript_name == \"SOD1-202\") sod1_202_cds <- sod1_cds %>% dplyr::filter(transcript_name == \"SOD1-202\")  sod1_201_202_plot <- sod1_201_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = \"SOD1-201/202\"     )) +     geom_half_range(         fill = \"white\",         height = 0.125     ) +     geom_half_range(         data = sod1_201_cds     ) +     geom_intron(         data = to_intron(sod1_201_exons, \"transcript_name\")     ) +     geom_half_range(         data = sod1_202_exons,         range.orientation = \"top\",         fill = \"white\",         height = 0.125     ) +     geom_half_range(         data = sod1_202_cds,         range.orientation = \"top\",         fill = \"purple\"     ) +     geom_intron(         data = to_intron(sod1_202_exons, \"transcript_name\")     )  sod1_201_202_plot sod1_201_202_plot + coord_cartesian(xlim = c(31659500, 31660000)) # ggtranscript includes a set of example (unannotated) junctions # originating from GTEx and downloaded via the Bioconductor package snapcount sod1_junctions #> # A tibble: 5 × 5 #>   seqnames    start      end strand mean_count #>   <fct>       <int>    <int> <fct>       <dbl> #> 1 chr21    31659787 31666448 +           0.463 #> 2 chr21    31659842 31660554 +           0.831 #> 3 chr21    31659842 31663794 +           0.316 #> 4 chr21    31659842 31667257 +           4.35  #> 5 chr21    31660351 31663789 +           0.324  # add transcript_name to junctions for plotting sod1_junctions <- sod1_junctions %>%     dplyr::mutate(transcript_name = \"SOD1-201\")  sod1_201_exons %>%   ggplot(aes(     xstart = start,     xend = end,     y = transcript_name   )) +   geom_range(     fill = \"white\",      height = 0.25   ) +   geom_range(     data = sod1_201_cds   ) +    geom_intron(     data = to_intron(sod1_201_exons, \"transcript_name\")   ) +    geom_junction(     data = sod1_junctions,     junction.y.max = 0.5   ) +   geom_junction_label_repel(     data = sod1_junctions,     aes(label = round(mean_count, 2)),     junction.y.max = 0.5   ) sod1_201_exons %>%   ggplot(aes(     xstart = start,     xend = end,     y = transcript_name   )) +   geom_range(     fill = \"white\",      height = 0.25   ) +   geom_range(     data = sod1_201_cds   ) +    geom_intron(     data = to_intron(sod1_201_exons, \"transcript_name\")   ) +    geom_junction(     data = sod1_junctions,     aes(size = mean_count),     junction.y.max = 0.5,      ncp = 30,      colour = \"purple\"   ) +    scale_size_continuous(range = c(0.1, 1), guide = \"none\") +    xlab(\"Genomic position (chr21)\") +    ylab(\"Transcript name\") +    theme_bw() #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated."},{"path":"/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Visualizing Transcript Structure and Annotation using ggplot2","text":"","code":"citation(\"ggtranscript\") #> To cite package 'ggtranscript' in publications use: #>  #>   Gustavsson EK, Zhang D, Reynolds RH, Garcia-Ruiz S, Ryten M (2022). #>   \"ggtranscript: an R package for the visualization and interpretation #>   of transcript isoforms using ggplot2.\" _Bioinformatics_. #>   doi:10.1093/bioinformatics/btac409 #>   <https://doi.org/10.1093/bioinformatics/btac409>, #>   <https://academic.oup.com/bioinformatics/article/38/15/3844/6617821>. #>  #> A BibTeX entry for LaTeX users is #>  #>   @Article{, #>     title = {ggtranscript: an R package for the visualization and interpretation of transcript isoforms using ggplot2}, #>     author = {Emil K Gustavsson and David Zhang and Regina H Reynolds and Sonia Garcia-Ruiz and Mina Ryten}, #>     year = {2022}, #>     journal = {Bioinformatics}, #>     doi = {https://doi.org/10.1093/bioinformatics/btac409}, #>     url = {https://academic.oup.com/bioinformatics/article/38/15/3844/6617821}, #>   }"},{"path":"/index.html","id":"credits","dir":"","previous_headings":"","what":"Credits","title":"Visualizing Transcript Structure and Annotation using ggplot2","text":"ggtranscript developed using biocthis.","code":""},{"path":"/reference/add_exon_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Add exon number — add_exon_number","title":"Add exon number — add_exon_number","text":"add_exon_number() adds exon number (order exons transcribed within transcript) column exons. can useful visualizing long, complex transcript structures, order keep track specific exons interest.","code":""},{"path":"/reference/add_exon_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add exon number — add_exon_number","text":"","code":"add_exon_number(exons, group_var = NULL)"},{"path":"/reference/add_exon_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add exon number — add_exon_number","text":"exons data.frame() contains exons can originate multiple transcripts differentiated group_var. group_var character() input data originates 1 transcript, group_var must specify column differentiates transcripts (e.g. \"transcript_id\").","code":""},{"path":"/reference/add_exon_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add exon number — add_exon_number","text":"data.frame() equivalent input exons, additional column \"exon_number\".","code":""},{"path":"/reference/add_exon_number.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add exon number — add_exon_number","text":"note, \"strand\" column must present within exons. strand used differentiate whether exon numbers calculated according ascending (\"+\") descending (\"-\") genomic co-ordinates. ambiguous strands (\"*\"), add_exon_number() assume strand \"+\".","code":""},{"path":"/reference/add_exon_number.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add exon number — add_exon_number","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(type == \"exon\") sod1_exons %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       31659666 31659784 +      exon  SOD1      SOD1-202        #> 2 21       31663790 31663886 +      exon  SOD1      SOD1-202        #> 3 21       31666449 31666518 +      exon  SOD1      SOD1-202        #> 4 21       31667258 31667375 +      exon  SOD1      SOD1-202        #> 5 21       31668471 31668931 +      exon  SOD1      SOD1-202        #> 6 21       31659693 31659841 +      exon  SOD1      SOD1-204        #> # ℹ 1 more variable: transcript_biotype <chr>  # add the exon number for each transcript sod1_exons <- sod1_exons %>% add_exon_number(group_var = \"transcript_name\")  base <- sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\"),         strand = \"+\"     )  # it can be useful to annotate exons with their exon number # using ggplot2::geom_text() base +     geom_text(aes(         x = (start + end) / 2, # plot label at midpoint of exon         label = exon_number     ),     size = 3.5,     nudge_y = 0.4     )   # Or alternatively, using ggrepel::geom_label_repel() # to separate labels from exons base +     ggrepel::geom_label_repel(ggplot2::aes(         x = (start + end) / 2,         label = exon_number     ),     size = 3.5,     min.segment.length = 0     )"},{"path":"/reference/add_utr.html","id":null,"dir":"Reference","previous_headings":"","what":"Add untranslated regions (UTRs) — add_utr","title":"Add untranslated regions (UTRs) — add_utr","text":"Given set exons (encompassing CDS UTRs) cds regions, add_utr() calculate add corresponding UTR regions ranges. can useful combined shorten_gaps() visualize transcripts long introns, whilst differentiating UTRs CDS regions.","code":""},{"path":"/reference/add_utr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add untranslated regions (UTRs) — add_utr","text":"","code":"add_utr(exons, cds, group_var = NULL)"},{"path":"/reference/add_utr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add untranslated regions (UTRs) — add_utr","text":"exons data.frame() contains exons can originate multiple transcripts differentiated group_var. cds data.frame() contains coding sequence ranges transcripts exons. group_var character() input data originates 1 transcript, group_var must specify column differentiates transcripts (e.g. \"transcript_id\").","code":""},{"path":"/reference/add_utr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add untranslated regions (UTRs) — add_utr","text":"data.frame() contains differentiated CDS UTR ranges.","code":""},{"path":"/reference/add_utr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add untranslated regions (UTRs) — add_utr","text":"definition inputted cds regions expected range beginning start codon end stop codon. Sometimes, example case Ensembl, reference annotation omit stop codons CDS definition. cases, users manually ensure cds includes start stop codons.","code":""},{"path":"/reference/add_utr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add untranslated regions (UTRs) — add_utr","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation pknox1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type       gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>      <chr>     <chr>           #> 1 21       42974510 43033931 +      gene       PKNOX1    NA              #> 2 21       42974510 43033931 +      transcript PKNOX1    PKNOX1-203      #> 3 21       42974510 42974664 +      exon       PKNOX1    PKNOX1-203      #> 4 21       43004326 43004432 +      exon       PKNOX1    PKNOX1-203      #> 5 21       43007491 43007618 +      exon       PKNOX1    PKNOX1-203      #> 6 21       43013068 43013238 +      exon       PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons pknox1_exons <- pknox1_annotation %>% dplyr::filter(type == \"exon\") pknox1_exons %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       42974510 42974664 +      exon  PKNOX1    PKNOX1-203      #> 2 21       43004326 43004432 +      exon  PKNOX1    PKNOX1-203      #> 3 21       43007491 43007618 +      exon  PKNOX1    PKNOX1-203      #> 4 21       43013068 43013238 +      exon  PKNOX1    PKNOX1-203      #> 5 21       43016908 43017007 +      exon  PKNOX1    PKNOX1-203      #> 6 21       43018133 43018230 +      exon  PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  # extract cds pknox1_cds <- pknox1_annotation %>% dplyr::filter(type == \"CDS\") pknox1_cds %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       43013068 43013238 +      CDS   PKNOX1    PKNOX1-203      #> 2 21       43016908 43017007 +      CDS   PKNOX1    PKNOX1-203      #> 3 21       43018133 43018230 +      CDS   PKNOX1    PKNOX1-203      #> 4 21       43021303 43021431 +      CDS   PKNOX1    PKNOX1-203      #> 5 21       43024871 43024947 +      CDS   PKNOX1    PKNOX1-203      #> 6 21       43028702 43028874 +      CDS   PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  # the CDS definition originating from the Ensembl reference annotation # does not include the stop codon # we must incorporate the stop codons into the CDS manually # by adding 3 base pairs to the end of the CDS of each transcript pknox1_cds_w_stop <- pknox1_cds %>%     dplyr::group_by(transcript_name) %>%     dplyr::mutate(         end = ifelse(end == max(end), end + 3, end)     ) %>%     dplyr::ungroup()  # add_utr() adds ranges that represent the UTRs pknox1_cds_utr <- add_utr(     pknox1_exons,     pknox1_cds_w_stop,     group_var = \"transcript_name\" )  pknox1_cds_utr %>% head() #> # A tibble: 6 × 9 #>   seqnames    start      end width strand transcript_name type  gene_name #>   <fct>       <int>    <int> <int> <fct>  <chr>           <chr> <chr>     #> 1 21       42974510 42974664   155 +      PKNOX1-203      UTR   NA        #> 2 21       43004326 43004432   107 +      PKNOX1-203      UTR   NA        #> 3 21       43007491 43007618   128 +      PKNOX1-203      UTR   NA        #> 4 21       43013068 43013238   171 +      PKNOX1-203      CDS   PKNOX1    #> 5 21       43016908 43017007   100 +      PKNOX1-203      CDS   PKNOX1    #> 6 21       43018133 43018230    98 +      PKNOX1-203      CDS   PKNOX1    #> # ℹ 1 more variable: transcript_biotype <chr>  # this can be useful when combined with shorten_gaps() # to visualize transcripts with long introns whilst differentiating UTRs pknox1_cds_utr_rescaled <-     shorten_gaps(         exons = pknox1_cds_utr,         introns = to_intron(pknox1_cds_utr, \"transcript_name\"),         group_var = \"transcript_name\"     )  pknox1_cds_utr_rescaled %>%     dplyr::filter(type == \"CDS\") %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_range(         data = pknox1_cds_utr_rescaled %>% dplyr::filter(type == \"UTR\"),         height = 0.25,         fill = \"white\"     ) +     geom_intron(         data = to_intron(             pknox1_cds_utr_rescaled %>% dplyr::filter(type != \"intron\"),             \"transcript_name\"         ),         arrow.min.intron.length = 110     )"},{"path":"/reference/geom_intron.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot intron lines with strand arrows — geom_intron","title":"Plot intron lines with strand arrows — geom_intron","text":"geom_intron() draws horizontal lines central arrows designed represent introns. combination geom_range()/geom_half_range(), geoms form core components visualizing transcript structures.","code":""},{"path":"/reference/geom_intron.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot intron lines with strand arrows — geom_intron","text":"","code":"geom_intron(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   arrow = grid::arrow(ends = \"last\", length = grid::unit(0.1, \"inches\")),   arrow.fill = NULL,   lineend = \"butt\",   linejoin = \"round\",   na.rm = FALSE,   arrow.min.intron.length = 0,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"/reference/geom_intron.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot intron lines with strand arrows — geom_intron","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. arrow specification arrow heads, created grid::arrow(). arrow.fill fill colour use arrow head (closed). NULL means use colour aesthetic. lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. arrow.min.intron.length integer() minimum required width intron strand arrow drawn. can useful remove strand arrows short introns overlap adjacent exons. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders().","code":""},{"path":"/reference/geom_intron.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot intron lines with strand arrows — geom_intron","text":"return value geom_* function intended directly handled users. Therefore, geom_* functions never executed isolation, rather used combination ggplot2::ggplot() call.","code":""},{"path":"/reference/geom_intron.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot intron lines with strand arrows — geom_intron","text":"geom_intron() requires following aes(); xstart, xend y (e.g. transcript name). users intron co-ordinates, can generated corresponding exons using to_intron(). strand option (one \"+\" \"-\") adjusts arrow direction match direction transcription. arrow.min.intron.length parameter can useful remove strand arrows overlap exons, can problem plotted introns include relatively short.","code":""},{"path":"/reference/geom_intron.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot intron lines with strand arrows — geom_intron","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation pknox1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type       gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>      <chr>     <chr>           #> 1 21       42974510 43033931 +      gene       PKNOX1    NA              #> 2 21       42974510 43033931 +      transcript PKNOX1    PKNOX1-203      #> 3 21       42974510 42974664 +      exon       PKNOX1    PKNOX1-203      #> 4 21       43004326 43004432 +      exon       PKNOX1    PKNOX1-203      #> 5 21       43007491 43007618 +      exon       PKNOX1    PKNOX1-203      #> 6 21       43013068 43013238 +      exon       PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons pknox1_exons <- pknox1_annotation %>% dplyr::filter(type == \"exon\") pknox1_exons %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       42974510 42974664 +      exon  PKNOX1    PKNOX1-203      #> 2 21       43004326 43004432 +      exon  PKNOX1    PKNOX1-203      #> 3 21       43007491 43007618 +      exon  PKNOX1    PKNOX1-203      #> 4 21       43013068 43013238 +      exon  PKNOX1    PKNOX1-203      #> 5 21       43016908 43017007 +      exon  PKNOX1    PKNOX1-203      #> 6 21       43018133 43018230 +      exon  PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  # to_intron() is a helper function included in ggtranscript # which is useful for converting exon co-ordinates to introns pknox1_introns <- pknox1_exons %>% to_intron(group_var = \"transcript_name\") pknox1_introns %>% head() #> # A tibble: 6 × 8 #>   seqnames strand type   gene_name transcript_name transcript_biotype    start #>   <fct>    <fct>  <chr>  <chr>     <chr>           <chr>                 <int> #> 1 21       +      intron PKNOX1    PKNOX1-203      protein_coding     42974664 #> 2 21       +      intron PKNOX1    PKNOX1-202      retained_intron    42974664 #> 3 21       +      intron PKNOX1    PKNOX1-201      protein_coding     42974664 #> 4 21       +      intron PKNOX1    PKNOX1-206      retained_intron    42974664 #> 5 21       +      intron PKNOX1    PKNOX1-204      retained_intron    43004432 #> 6 21       +      intron PKNOX1    PKNOX1-203      protein_coding     43004432 #> # ℹ 1 more variable: end <int>  base <- pknox1_introns %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     ))  # by default, geom_intron() assumes introns originate from the \"+\" strand base + geom_intron()   # however this can be modified using the strand option base + geom_intron(strand = \"-\")   # strand can also be set as an aes() base + geom_intron(aes(strand = strand))   # as a ggplot2 extension, ggtranscript geoms inherit the # the functionality from the parameters and aesthetics in ggplot2 base + geom_intron(     aes(colour = transcript_name),     linewidth = 1 )   # together, geom_range() and geom_intron() are designed to visualize # the core components of transcript annotation pknox1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = pknox1_introns     )   # for short introns, sometimes strand arrows will overlap exons # to avoid this, users can set the arrow.min.intron.length parameter pknox1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = pknox1_introns,         arrow.min.intron.length = 3500     )"},{"path":"/reference/geom_junction.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot junction curves — geom_junction","title":"Plot junction curves — geom_junction","text":"geom_junction() draws curves designed represent junction reads RNA-sequencing data. can useful overlay junction data transcript annotation (plotted using geom_range()/geom_half_range() geom_intron()) understand splicing events transcripts support RNA-sequencing data.","code":""},{"path":"/reference/geom_junction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot junction curves — geom_junction","text":"","code":"geom_junction(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   junction.orientation = \"alternating\",   junction.y.max = 1,   angle = 90,   ncp = 15,   na.rm = FALSE,   orientation = NA,   show.legend = NA,   inherit.aes = TRUE,   ... )"},{"path":"/reference/geom_junction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot junction curves — geom_junction","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. junction.orientation character() one \"alternating\", \"top\" \"bottom\", specifying junctions plotted respect transcript (y). junction.y.max double() max y-value junction curve. can useful adjust parameter junction curves overlap one another/transcripts extend beyond plot margins. angle numeric value 0 180,     giving amount skew control     points curve.  Values less 90 skew curve towards     start point values greater 90 skew curve     towards end point. ncp number control points used draw curve.     control points creates smoother curve. na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. orientation orientation layer. default (NA) automatically determines orientation aesthetic mapping. rare event fails can given explicitly setting orientation either \"x\" \"y\". See Orientation section detail. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders(). ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend.","code":""},{"path":"/reference/geom_junction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot junction curves — geom_junction","text":"return value geom_* function intended directly handled users. Therefore, geom_* functions never executed isolation, rather used combination ggplot2::ggplot() call.","code":""},{"path":"/reference/geom_junction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot junction curves — geom_junction","text":"geom_junction() requires following aes(); xstart, xend y (e.g. transcript name). geom_junction() curves can modified using junction.y.max, can useful junctions overlap one another/transcripts extend beyond plot margins. default, junction curves alternate plotted top bottom transcript (y), however can modified via junction.orientation.","code":""},{"path":"/reference/geom_junction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot junction curves — geom_junction","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # as well as a set of example (unannotated) junctions # originating from GTEx and downloaded via the Bioconductor package snapcount sod1_junctions #> # A tibble: 5 × 5 #>   seqnames    start      end strand mean_count #>   <fct>       <int>    <int> <fct>       <dbl> #> 1 chr21    31659787 31666448 +           0.463 #> 2 chr21    31659842 31660554 +           0.831 #> 3 chr21    31659842 31663794 +           0.316 #> 4 chr21    31659842 31667257 +           4.35  #> 5 chr21    31660351 31663789 +           0.324  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(     type == \"exon\",     transcript_name == \"SOD1-201\" ) sod1_exons %>% head() #> # A tibble: 5 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       31659693 31659841 +      exon  SOD1      SOD1-201        #> 2 21       31663790 31663886 +      exon  SOD1      SOD1-201        #> 3 21       31666449 31666518 +      exon  SOD1      SOD1-201        #> 4 21       31667258 31667375 +      exon  SOD1      SOD1-201        #> 5 21       31668471 31668931 +      exon  SOD1      SOD1-201        #> # ℹ 1 more variable: transcript_biotype <chr>  # add transcript_name to junctions for plotting sod1_junctions <- sod1_junctions %>%     dplyr::mutate(transcript_name = \"SOD1-201\")  # junctions can be plotted as curves using geom_junction() base <- sod1_junctions %>%     ggplot2::ggplot(ggplot2::aes(         xstart = start,         xend = end,         y = transcript_name     ))  # sometimes, depending on the number and widths of transcripts and junctions # junctions will go overlap one another or extend beyond the plot margin base + geom_junction()   # in such cases, junction.y.max can be adjusted to modify the max y of curves base + geom_junction(junction.y.max = 0.5)   # ncp can be used improve the smoothness of curves base + geom_junction(junction.y.max = 0.5, ncp = 30)   # junction.orientation controls where the junction are plotted # with respect to each transcript # either alternating (default), or on the top or bottom base + geom_junction(junction.orientation = \"top\", junction.y.max = 0.5)  base + geom_junction(junction.orientation = \"bottom\", junction.y.max = 0.5)   # it can be useful useful to overlay junction curves onto existing annotation # plotted using geom_range() and geom_intron() base <- sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\")     )  base + geom_junction(     data = sod1_junctions,     junction.y.max = 0.5 )   # as a ggplot2 extension, ggtranscript geoms inherit the # the functionality from the parameters and aesthetics in ggplot2 # this can be useful when mapping junction thickness to their counts base + geom_junction(     data = sod1_junctions,     aes(linewidth = mean_count),     junction.y.max = 0.5,     colour = \"purple\" ) +     scale_linewidth(range = c(0.1, 1))   # it can be useful to combine geom_junction() with geom_half_range() sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_half_range() +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\")     ) +     geom_junction(         data = sod1_junctions,         aes(linewidth = mean_count),         junction.y.max = 0.5,         junction.orientation = \"top\",         colour = \"purple\"     ) +     scale_linewidth(range = c(0.1, 1))"},{"path":"/reference/geom_junction_label_repel.html","id":null,"dir":"Reference","previous_headings":"","what":"Label junction curves — geom_junction_label_repel","title":"Label junction curves — geom_junction_label_repel","text":"geom_junction_label_repel() labels junction curves midpoint using ggrepel::geom_label_repel(). can useful label compare junctions (plotted using geom_junction()) metrics usage (e.g. read counts percent-spliced-).","code":""},{"path":"/reference/geom_junction_label_repel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label junction curves — geom_junction_label_repel","text":"","code":"geom_junction_label_repel(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   parse = FALSE,   ...,   junction.orientation = \"alternating\",   junction.y.max = 1,   angle = 90,   ncp = 15,   box.padding = 0.25,   label.padding = 0.25,   point.padding = 1e-06,   label.r = 0.15,   label.size = 0.25,   min.segment.length = 0,   arrow = NULL,   force = 1,   force_pull = 1,   max.time = 0.5,   max.iter = 10000,   max.overlaps = getOption(\"ggrepel.max.overlaps\", default = 10),   nudge_x = 0,   nudge_y = 0,   xlim = c(NA, NA),   ylim = c(NA, NA),   na.rm = FALSE,   show.legend = NA,   direction = c(\"both\", \"y\", \"x\"),   seed = NA,   verbose = FALSE,   inherit.aes = TRUE )"},{"path":"/reference/geom_junction_label_repel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label junction curves — geom_junction_label_repel","text":"mapping Set aesthetic mappings created aes aes_. specified inherit.aes = TRUE (default), combined default mapping top level plot. need supply mapping mapping defined plot. data data frame. specified, overrides default data frame defined top level plot. stat statistical transformation use data layer, string. position Position adjustment, either string, result call position adjustment function. parse TRUE, labels parsed expressions displayed described ?plotmath ... arguments passed layer.   three types arguments can use :  Aesthetics: set aesthetic fixed value, like        colour = \"red\" size = 3. arguments layer, example override       default stat associated layer. arguments passed stat. junction.orientation character() one \"alternating\", \"top\" \"bottom\", specifying junctions plotted respect transcript (y). junction.y.max double() max y-value junction curve. can useful adjust parameter junction curves overlap one another/transcripts extend beyond plot margins. angle numeric value 0 180,     giving amount skew control     points curve.  Values less 90 skew curve towards     start point values greater 90 skew curve     towards end point. ncp number control points used draw curve.     control points creates smoother curve. box.padding Amount padding around bounding box, unit number. Defaults 0.25. (Default unit lines, units can specified passing unit(x, \"units\")). label.padding Amount padding around label, unit number. Defaults 0.25. (Default unit lines, units can specified passing unit(x, \"units\")). point.padding Amount padding around labeled point, unit number. Defaults 0. (Default unit lines, units can specified passing unit(x, \"units\")). label.r Radius rounded corners, unit number. Defaults 0.15. (Default unit lines, units can specified passing unit(x, \"units\")). label.size Size label border, mm. min.segment.length Skip drawing segments shorter , unit number. Defaults 0.5. (Default unit lines, units can specified passing unit(x, \"units\")). arrow specification arrow heads, created arrow force Force repulsion overlapping text labels. Defaults 1. force_pull Force attraction text label corresponding data point. Defaults 1. max.time Maximum number seconds try resolve overlaps. Defaults 0.5. max.iter Maximum number iterations try resolve overlaps. Defaults 10000. max.overlaps Exclude text labels overlap many things. text label, count many text labels data points overlaps, exclude text label many overlaps. Defaults 10. nudge_x, nudge_y Horizontal vertical adjustments nudge starting position text label. units nudge_x nudge_y data units x-axis y-axis. xlim, ylim Limits x y axes. Text labels constrained limits. default, text labels constrained entire plot area. na.rm FALSE (default), removes missing values warning.  TRUE silently removes missing values. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. direction \"\", \"x\", \"y\" – direction adjust position labels seed Random seed passed set.seed. Defaults NA, means set.seed called. verbose TRUE, diagnostics repel algorithm printed inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders.","code":""},{"path":"/reference/geom_junction_label_repel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label junction curves — geom_junction_label_repel","text":"return value geom_* function intended directly handled users. Therefore, geom_* functions never executed isolation, rather used combination ggplot2::ggplot() call.","code":""},{"path":"/reference/geom_junction_label_repel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label junction curves — geom_junction_label_repel","text":"geom_junction_label_repel() requires following aes(); xstart, xend, y (e.g. transcript name) label. hood, geom_junction_label_repel() generates junction curves geom_junction() obtain curve midpoints labeling. Therefore, important users use input data parameters alter junction curves (namely junction.orientation, junction.y.max, angle, ncp) geom_junction_label_repel() used geom_junction().","code":""},{"path":"/reference/geom_junction_label_repel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label junction curves — geom_junction_label_repel","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # as well as a set of example (unannotated) junctions # originating from GTEx and downloaded via the Bioconductor package snapcount sod1_junctions #> # A tibble: 5 × 5 #>   seqnames    start      end strand mean_count #>   <fct>       <int>    <int> <fct>       <dbl> #> 1 chr21    31659787 31666448 +           0.463 #> 2 chr21    31659842 31660554 +           0.831 #> 3 chr21    31659842 31663794 +           0.316 #> 4 chr21    31659842 31667257 +           4.35  #> 5 chr21    31660351 31663789 +           0.324  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(     type == \"exon\",     transcript_name == \"SOD1-201\" ) sod1_exons %>% head() #> # A tibble: 5 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       31659693 31659841 +      exon  SOD1      SOD1-201        #> 2 21       31663790 31663886 +      exon  SOD1      SOD1-201        #> 3 21       31666449 31666518 +      exon  SOD1      SOD1-201        #> 4 21       31667258 31667375 +      exon  SOD1      SOD1-201        #> 5 21       31668471 31668931 +      exon  SOD1      SOD1-201        #> # ℹ 1 more variable: transcript_biotype <chr>  # add transcript_name to junctions for plotting sod1_junctions <- sod1_junctions %>%     dplyr::mutate(transcript_name = \"SOD1-201\")  # geom_junction_label_repel() can be used to label junctions base <- sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\")     )  # this can be useful to label junctions with their counts base +     geom_junction(         data = sod1_junctions,         junction.y.max = 0.5     ) +     geom_junction_label_repel(         data = sod1_junctions,         aes(label = round(mean_count, 2)),         junction.y.max = 0.5     )"},{"path":"/reference/geom_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot genomic ranges — geom_range","title":"Plot genomic ranges — geom_range","text":"geom_range() geom_half_range() draw tiles designed represent range-based genomic features, exons. combination geom_intron(), geoms form core components visualizing transcript structures.","code":""},{"path":"/reference/geom_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot genomic ranges — geom_range","text":"","code":"geom_range(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   vjust = NULL,   linejoin = \"mitre\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )  geom_half_range(   mapping = NULL,   data = NULL,   stat = \"identity\",   position = \"identity\",   ...,   range.orientation = \"bottom\",   linejoin = \"mitre\",   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE )"},{"path":"/reference/geom_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot genomic ranges — geom_range","text":"mapping Set aesthetic mappings created aes(). specified inherit.aes = TRUE (default), combined default mapping top level plot. must supply mapping plot mapping. data data displayed layer. three options: NULL, default, data inherited plot data specified call ggplot(). data.frame, object, override plot data. objects fortified produce data frame. See fortify() variables created. function called single argument, plot data. return value must data.frame, used layer data. function can created formula (e.g. ~ head(.x, 10)). stat statistical transformation use data layer. using geom_*() function construct layer, stat argument can used override default coupling geoms stats. stat argument accepts following: Stat ggproto subclass, example StatCount. string naming stat. give stat string, strip function name stat_ prefix. example, use stat_count(), give stat \"count\". information ways specify stat, see layer stat documentation. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend. vjust numeric vector specifying vertical justification.     specified, overrides just setting. linejoin Line join style (round, mitre, bevel). na.rm FALSE, default, missing values removed warning. TRUE, missing values silently removed. show.legend logical. layer included legends? NA, default, includes aesthetics mapped. FALSE never includes, TRUE always includes. can also named logical vector finely select aesthetics display. inherit.aes FALSE, overrides default aesthetics, rather combining . useful helper functions define data aesthetics inherit behaviour default plot specification, e.g. borders(). range.orientation character() one \"top\" \"bottom\", specifying half ranges plotted respect transcript (y).","code":""},{"path":"/reference/geom_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot genomic ranges — geom_range","text":"return value geom_* function intended directly handled users. Therefore, geom_* functions never executed isolation, rather used combination ggplot2::ggplot() call.","code":""},{"path":"/reference/geom_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot genomic ranges — geom_range","text":"geom_range() geom_half_range() require following aes(); xstart, xend y (e.g. transcript name). geom_half_range() takes advantage vertical symmetry transcript annotation plotting half range top bottom transcript structure. can useful comparing two transcripts free plotting space transcript annotations (e.g. geom_junction()).","code":""},{"path":"/reference/geom_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot genomic ranges — geom_range","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(type == \"exon\") sod1_exons %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       31659666 31659784 +      exon  SOD1      SOD1-202        #> 2 21       31663790 31663886 +      exon  SOD1      SOD1-202        #> 3 21       31666449 31666518 +      exon  SOD1      SOD1-202        #> 4 21       31667258 31667375 +      exon  SOD1      SOD1-202        #> 5 21       31668471 31668931 +      exon  SOD1      SOD1-202        #> 6 21       31659693 31659841 +      exon  SOD1      SOD1-204        #> # ℹ 1 more variable: transcript_biotype <chr>  base <- sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     ))  # geom_range() is designed to visualise range-based annotation such as exons base + geom_range()   # geom_half_range() allows users to plot half ranges # on the top or bottom of the transcript base + geom_half_range()   # where the half ranges are plotted can be adjusted using range.orientation base + geom_half_range(range.orientation = \"top\")   # as a ggplot2 extension, ggtranscript geoms inherit the # the functionality from the parameters and aesthetics in ggplot2 base + geom_range(     aes(fill = transcript_name),     linewidth = 1 )   # together, geom_range() and geom_intron() are designed to visualize # the core components of transcript annotation base + geom_range(     aes(fill = transcript_biotype) ) +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\")     )   # for protein coding transcripts # geom_range() be useful for visualizing UTRs that lie outside of the CDS sod1_exons_prot_coding <- sod1_exons %>%     dplyr::filter(transcript_biotype == \"protein_coding\")  # extract cds sod1_cds <- sod1_annotation %>%     dplyr::filter(type == \"CDS\")  sod1_exons_prot_coding %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range(         fill = \"white\",         height = 0.25     ) +     geom_range(         data = sod1_cds     ) +     geom_intron(         data = to_intron(sod1_exons_prot_coding, \"transcript_name\")     )   # geom_half_range() can be useful for comparing between two transcripts # enabling visualization of one transcript on the top, other on the bottom sod1_201_exons <- sod1_exons %>% dplyr::filter(transcript_name == \"SOD1-201\") sod1_201_cds <- sod1_cds %>% dplyr::filter(transcript_name == \"SOD1-201\") sod1_202_exons <- sod1_exons %>% dplyr::filter(transcript_name == \"SOD1-202\") sod1_202_cds <- sod1_cds %>% dplyr::filter(transcript_name == \"SOD1-202\")  sod1_201_plot <- sod1_201_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = \"SOD1-201/202\"     )) +     geom_half_range(         fill = \"white\",         height = 0.125     ) +     geom_half_range(         data = sod1_201_cds     ) +     geom_intron(         data = to_intron(sod1_201_exons, \"transcript_name\")     )  sod1_201_plot   sod1_201_202_plot <- sod1_201_plot +     geom_half_range(         data = sod1_202_exons,         range.orientation = \"top\",         fill = \"white\",         height = 0.125     ) +     geom_half_range(         data = sod1_202_cds,         range.orientation = \"top\",         fill = \"purple\"     ) +     geom_intron(         data = to_intron(sod1_202_exons, \"transcript_name\")     )  sod1_201_202_plot   # leveraging existing ggplot2 functionality via e.g. coord_cartesian() # can be useful to zoom in on areas of interest sod1_201_202_plot + coord_cartesian(xlim = c(31659500, 31660000))"},{"path":"/reference/ggtranscript.html","id":null,"dir":"Reference","previous_headings":"","what":"ggtranscript: Visualizing transcript structure and annotation using ggplot2 — ggtranscript","title":"ggtranscript: Visualizing transcript structure and annotation using ggplot2 — ggtranscript","text":"goal ggtranscript simplify process visualizing transcript structure annotation. achieve , ggtranscript introduces 5 new geoms (geom_range(), geom_half_range(), geom_intron(), geom_junction() geom_junction_label_repel()) well several helper functions. ggplot2 extension, ggtranscript inherits ggplot2's familiarity flexibility, enabling users intuitively adjust aesthetics, parameters, scales etc well complement ggtranscript geoms existing ggplot2 geoms create informative, publication-ready plots.","code":""},{"path":[]},{"path":"/reference/ggtranscript.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ggtranscript: Visualizing transcript structure and annotation using ggplot2 — ggtranscript","text":"Maintainer: David Zhang dyzhang32@gmail.com (ORCID) Authors: Emil Gustavsson e.gustavsson@ucl.ac.uk (ORCID) contributors: Regina Reynolds regina.reynolds.16@ucl.ac.uk (ORCID) [contributor] Sonia Ruiz s.ruiz@ucl.ac.uk [contributor]","code":""},{"path":"/reference/shorten_gaps.html","id":null,"dir":"Reference","previous_headings":"","what":"Improve transcript structure visualization by shortening gaps — shorten_gaps","title":"Improve transcript structure visualization by shortening gaps — shorten_gaps","text":"given set exons introns, shorten_gaps() reduces width gaps (regions overlap exons) user-inputted target_gap_width. can useful visualizing transcripts long introns, hone regions interest (.e. exons) better compare transcript structures.","code":""},{"path":"/reference/shorten_gaps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Improve transcript structure visualization by shortening gaps — shorten_gaps","text":"","code":"shorten_gaps(exons, introns, group_var = NULL, target_gap_width = 100L)"},{"path":"/reference/shorten_gaps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Improve transcript structure visualization by shortening gaps — shorten_gaps","text":"exons data.frame() contains exons can originate multiple transcripts differentiated group_var. introns data.frame() intron co-ordinates corresponding input exons. can created applying to_intron() exons. introns originate multiple transcripts, must differentiated using group_var. user using to_intron(), must make sure intron start/ends defined precisely adjacent exon boundaries (rather exon end + 1 exon start - 1). group_var character() input data originates 1 transcript, group_var must specify column differentiates transcripts (e.g. \"transcript_id\"). target_gap_width integer() width base pairs shorten gaps .","code":""},{"path":"/reference/shorten_gaps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Improve transcript structure visualization by shortening gaps — shorten_gaps","text":"data.frame() contains re-scaled co-ordinates introns exons input transcript shortened gaps.","code":""},{"path":"/reference/shorten_gaps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Improve transcript structure visualization by shortening gaps — shorten_gaps","text":"shorten_gaps() reduces size gaps, re-scale exons introns preserve exon alignment. process reduce width input introns, never exons. Importantly, outputted re-scaled co-ordinates used visualization match original genomic coordinates.","code":""},{"path":"/reference/shorten_gaps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Improve transcript structure visualization by shortening gaps — shorten_gaps","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation pknox1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type       gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>      <chr>     <chr>           #> 1 21       42974510 43033931 +      gene       PKNOX1    NA              #> 2 21       42974510 43033931 +      transcript PKNOX1    PKNOX1-203      #> 3 21       42974510 42974664 +      exon       PKNOX1    PKNOX1-203      #> 4 21       43004326 43004432 +      exon       PKNOX1    PKNOX1-203      #> 5 21       43007491 43007618 +      exon       PKNOX1    PKNOX1-203      #> 6 21       43013068 43013238 +      exon       PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons pknox1_exons <- pknox1_annotation %>% dplyr::filter(type == \"exon\") pknox1_exons %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       42974510 42974664 +      exon  PKNOX1    PKNOX1-203      #> 2 21       43004326 43004432 +      exon  PKNOX1    PKNOX1-203      #> 3 21       43007491 43007618 +      exon  PKNOX1    PKNOX1-203      #> 4 21       43013068 43013238 +      exon  PKNOX1    PKNOX1-203      #> 5 21       43016908 43017007 +      exon  PKNOX1    PKNOX1-203      #> 6 21       43018133 43018230 +      exon  PKNOX1    PKNOX1-203      #> # ℹ 1 more variable: transcript_biotype <chr>  # to_intron() is a helper function included in ggtranscript # which is useful for converting exon co-ordinates to introns pknox1_introns <- pknox1_exons %>% to_intron(group_var = \"transcript_name\") pknox1_introns %>% head() #> # A tibble: 6 × 8 #>   seqnames strand type   gene_name transcript_name transcript_biotype    start #>   <fct>    <fct>  <chr>  <chr>     <chr>           <chr>                 <int> #> 1 21       +      intron PKNOX1    PKNOX1-203      protein_coding     42974664 #> 2 21       +      intron PKNOX1    PKNOX1-202      retained_intron    42974664 #> 3 21       +      intron PKNOX1    PKNOX1-201      protein_coding     42974664 #> 4 21       +      intron PKNOX1    PKNOX1-206      retained_intron    42974664 #> 5 21       +      intron PKNOX1    PKNOX1-204      retained_intron    43004432 #> 6 21       +      intron PKNOX1    PKNOX1-203      protein_coding     43004432 #> # ℹ 1 more variable: end <int>  # for transcripts with long introns, the exons of interest # can be difficult to visualize clearly when using the default scale pknox1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = pknox1_introns,         arrow.min.intron.length = 3500     )   # in such cases it can be useful to rescale the exons and introns # using shorten_gaps() which shortens regions that do not overlap an exon pknox1_rescaled <-     shorten_gaps(pknox1_exons, pknox1_introns, group_var = \"transcript_name\")  pknox1_rescaled %>% head() #> # A tibble: 6 × 8 #>   seqnames start   end strand type  gene_name transcript_name transcript_biotype #>   <fct>    <dbl> <dbl> <fct>  <chr> <chr>     <chr>           <chr>              #> 1 21          54   156 +      exon  PKNOX1    PKNOX1-201      protein_coding     #> 2 21         156   694 +      intr… PKNOX1    PKNOX1-201      protein_coding     #> 3 21         694   800 +      exon  PKNOX1    PKNOX1-201      protein_coding     #> 4 21         800   901 +      intr… PKNOX1    PKNOX1-201      protein_coding     #> 5 21         901  1028 +      exon  PKNOX1    PKNOX1-201      protein_coding     #> 6 21        1028  1223 +      intr… PKNOX1    PKNOX1-201      protein_coding      # this allows us to visualize differences in exonic structure more clearly pknox1_rescaled %>%     dplyr::filter(type == \"exon\") %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = pknox1_rescaled %>% dplyr::filter(type == \"intron\"),         arrow.min.intron.length = 300     )   # shorten_gaps() can be used in combination with to_diff() # to further highlight differences in exon structure # here, all other transcripts are compared to the MANE-select transcript pknox1_rescaled_diffs <- to_diff(     exons = pknox1_rescaled %>%         dplyr::filter(type == \"exon\", transcript_name != \"PKNOX1-201\"),     ref_exons = pknox1_rescaled %>%         dplyr::filter(type == \"exon\", transcript_name == \"PKNOX1-201\"),     group_var = \"transcript_name\" )  pknox1_rescaled %>%     dplyr::filter(type == \"exon\") %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = pknox1_rescaled %>% dplyr::filter(type == \"intron\"),         arrow.min.intron.length = 300     ) +     geom_range(         data = pknox1_rescaled_diffs,         aes(fill = diff_type),         alpha = 0.2     )"},{"path":"/reference/sod1_annotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Example transcript annotation — sod1_annotation","title":"Example transcript annotation — sod1_annotation","text":"Transcript annotation including co-ordinates (hg38) genes, transcripts, exons CDS regions SOD1 PKNOX1, originate version 105 Ensembl reference annotation.","code":""},{"path":"/reference/sod1_annotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example transcript annotation — sod1_annotation","text":"","code":"sod1_annotation  pknox1_annotation"},{"path":"/reference/sod1_annotation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example transcript annotation — sod1_annotation","text":"tibble::tibble(): seqnames factor() chromosome. start integer() start position. end integer() end position. strand factor() strand. type factor() E.g.gene, transcript, exon CDS. gene_name character() name gene (GBA). transcript_name character() name transcript. transcript_biotype character() biotype transcript. object class tbl_df (inherits tbl, data.frame) 112 rows 8 columns.","code":""},{"path":"/reference/sod1_annotation.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example transcript annotation — sod1_annotation","text":"generated using ggtranscript/data-raw/sod1_pknox1_annotation.R","code":""},{"path":"/reference/sod1_junctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Example junctions — sod1_junctions","title":"Example junctions — sod1_junctions","text":"Junction co-ordinates counts associated SOD1 gene. Junctions counts originate GTEx liver samples downloaded via Bioconductor package snapcount. unannotated junctions mean count 0.3 retained example.","code":""},{"path":"/reference/sod1_junctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example junctions — sod1_junctions","text":"","code":"sod1_junctions"},{"path":"/reference/sod1_junctions.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example junctions — sod1_junctions","text":"tibble::tibble(): seqnames factor() chromosome. start integer() start position. end integer() end position. strand factor() strand. mean_count factor() Average count across GTEx liver samples.","code":""},{"path":"/reference/sod1_junctions.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example junctions — sod1_junctions","text":"generated using ggtranscript/data-raw/sod1_junctions.R","code":""},{"path":"/reference/to_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain the differences between transcript structure — to_diff","title":"Obtain the differences between transcript structure — to_diff","text":"to_diff() obtains difference exons set transcripts reference transcript (ref_exons). can useful visualizing differences transcript structure. to_diff() expects two sets input exons; 1. exons - exons number transcripts compared ref_exons 2. ref_exons - exons single transcript acts reference compare .","code":""},{"path":"/reference/to_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain the differences between transcript structure — to_diff","text":"","code":"to_diff(exons, ref_exons, group_var = NULL)"},{"path":"/reference/to_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain the differences between transcript structure — to_diff","text":"exons data.frame() contains exons can originate multiple transcripts differentiated group_var. ref_exons data.frame() contains exons originate single transcript, exons compared . group_var character() input data originates 1 transcript, group_var must specify column differentiates transcripts (e.g. \"transcript_id\").","code":""},{"path":"/reference/to_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain the differences between transcript structure — to_diff","text":"data.frame() details differences exons ref_exons.","code":""},{"path":"/reference/to_diff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain the differences between transcript structure — to_diff","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(type == \"exon\") sod1_exons %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       31659666 31659784 +      exon  SOD1      SOD1-202        #> 2 21       31663790 31663886 +      exon  SOD1      SOD1-202        #> 3 21       31666449 31666518 +      exon  SOD1      SOD1-202        #> 4 21       31667258 31667375 +      exon  SOD1      SOD1-202        #> 5 21       31668471 31668931 +      exon  SOD1      SOD1-202        #> 6 21       31659693 31659841 +      exon  SOD1      SOD1-204        #> # ℹ 1 more variable: transcript_biotype <chr>  # for this example, let's compare transcripts to the MANE-select transcript sod1_mane <- sod1_exons %>% dplyr::filter(transcript_name == \"SOD1-201\") sod1_not_mane <- sod1_exons %>% dplyr::filter(transcript_name != \"SOD1-201\")  # to_diff() obtains the differences between the exons as ranges sod1_diffs <- to_diff(     exons = sod1_not_mane,     ref_exons = sod1_mane,     group_var = \"transcript_name\" )  sod1_diffs %>% head() #>   seqnames    start      end width strand type  diff_type transcript_name #> 1       21 31659666 31659692    27      + diff not_in_ref        SOD1-202 #> 2       21 31659785 31659841    57      + diff     in_ref        SOD1-202 #> 3       21 31661549 31661734   186      + diff not_in_ref        SOD1-204 #> 4       21 31667342 31667375    34      + diff     in_ref        SOD1-204 #> 5       21 31668471 31668931   461      + diff     in_ref        SOD1-204 #> 6       21 31659693 31659708    16      + diff     in_ref        SOD1-203  # using geom_range(), it can be useful to visually overlay # the differences on top of the transcript annotation sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\")     ) +     geom_range(         data = sod1_diffs,         ggplot2::aes(fill = diff_type),         alpha = 0.2     )"},{"path":"/reference/to_intron.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert exon co-ordinates to introns — to_intron","title":"Convert exon co-ordinates to introns — to_intron","text":"Given set exons, to_intron() return corresponding introns.","code":""},{"path":"/reference/to_intron.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert exon co-ordinates to introns — to_intron","text":"","code":"to_intron(exons, group_var = NULL)"},{"path":"/reference/to_intron.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert exon co-ordinates to introns — to_intron","text":"exons data.frame() contains exons can originate multiple transcripts differentiated group_var. group_var character() input data originates 1 transcript, group_var must specify column differentiates transcripts (e.g. \"transcript_id\").","code":""},{"path":"/reference/to_intron.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert exon co-ordinates to introns — to_intron","text":"data.frame() contains intron co-ordinates.","code":""},{"path":"/reference/to_intron.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert exon co-ordinates to introns — to_intron","text":"important note , visualization purposes, to_intron() defines introns precisely exon boundaries, rather intron start/end (exon end + 1)/(exon start - 1).","code":""},{"path":"/reference/to_intron.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert exon co-ordinates to introns — to_intron","text":"","code":"library(magrittr) library(ggplot2)  # to illustrate the package's functionality # ggtranscript includes example transcript annotation sod1_annotation %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type        gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct>       <chr>     <chr>           #> 1 21       31659666 31668931 +      gene        SOD1      NA              #> 2 21       31659666 31668931 +      transcript  SOD1      SOD1-202        #> 3 21       31659666 31659784 +      exon        SOD1      SOD1-202        #> 4 21       31659770 31659784 +      CDS         SOD1      SOD1-202        #> 5 21       31659770 31659772 +      start_codon SOD1      SOD1-202        #> 6 21       31663790 31663886 +      exon        SOD1      SOD1-202        #> # ℹ 1 more variable: transcript_biotype <chr>  # extract exons sod1_exons <- sod1_annotation %>% dplyr::filter(type == \"exon\") sod1_exons %>% head() #> # A tibble: 6 × 8 #>   seqnames    start      end strand type  gene_name transcript_name #>   <fct>       <int>    <int> <fct>  <fct> <chr>     <chr>           #> 1 21       31659666 31659784 +      exon  SOD1      SOD1-202        #> 2 21       31663790 31663886 +      exon  SOD1      SOD1-202        #> 3 21       31666449 31666518 +      exon  SOD1      SOD1-202        #> 4 21       31667258 31667375 +      exon  SOD1      SOD1-202        #> 5 21       31668471 31668931 +      exon  SOD1      SOD1-202        #> 6 21       31659693 31659841 +      exon  SOD1      SOD1-204        #> # ℹ 1 more variable: transcript_biotype <chr>  # to_intron() is a helper function included in ggtranscript # which is useful for converting exon co-ordinates to introns sod1_introns <- sod1_exons %>% to_intron(group_var = \"transcript_name\") sod1_introns %>% head() #> # A tibble: 6 × 8 #>   seqnames strand type   gene_name transcript_name transcript_biotype      start #>   <fct>    <fct>  <chr>  <chr>     <chr>           <chr>                   <int> #> 1 21       +      intron SOD1      SOD1-204        processed_transcript 31659841 #> 2 21       +      intron SOD1      SOD1-202        protein_coding       31659784 #> 3 21       +      intron SOD1      SOD1-204        processed_transcript 31661734 #> 4 21       +      intron SOD1      SOD1-201        protein_coding       31659841 #> 5 21       +      intron SOD1      SOD1-203        processed_transcript 31660708 #> 6 21       +      intron SOD1      SOD1-202        protein_coding       31663886 #> # ℹ 1 more variable: end <int>  # this can be particular useful when combined with # geom_range() and geom_intron() # to visualize the core components of transcript annotation sod1_exons %>%     ggplot(aes(         xstart = start,         xend = end,         y = transcript_name     )) +     geom_range() +     geom_intron(         data = to_intron(sod1_exons, \"transcript_name\")     )"},{"path":[]},{"path":"/news/index.html","id":"fixes-1-0-0","dir":"Changelog","previous_headings":"","what":"Fixes","title":"ggtranscript 1.0.0","text":"Updates geoms work latest version ggplot2 ggrepel (R version 4.4). Fixes unit tests. Fixes CI workflow issues simplifies testing linux-.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-9","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.9","text":"Address ggtranscript reviews; update docs examples using gtf/bed files, integration ggplot2 extensions add usage shorten_gaps() README.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-8","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.8","text":"Address CRAN feedback; changing ggplot2 -> ‘ggplot2’, remove biocViews contributing, removing Date field DESCRIPTION.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-7","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.7","text":"Add cran-comments.md preparation first CRAN submission. Update CI run R CMD Check latest R version (4.2).","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-6","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.6","text":"Add @return documentation geom_* functions BiocCheck.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-5","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.5","text":"Change branch naming main master match BBS.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-4","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.4","text":"Change email UCL email Bioconductor submission.","code":""},{"path":"/news/index.html","id":"new-features-0-99-4-1","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.4","text":"Add add_utr() adding UTRs ranges. helper function designed work shorten_gaps(), enabling shortening gaps whilst visually differentiating UTRs CDS. Allow to_intron() take CDS UTRs ranges input. Submit Bioconductor.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-2","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.2","text":"Add geom_junction_label_repel() labeling junctions (e.g. counts). Add add_exon_number() visualizing exon number/order.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-99-1","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"ggtranscript 0.99.1","text":"Implement base geoms: geom_range(), geom_half_range(), geom_intron(), geom_junction() helper functions: to_intron(), to_diff() shorten_gaps().","code":""}]
